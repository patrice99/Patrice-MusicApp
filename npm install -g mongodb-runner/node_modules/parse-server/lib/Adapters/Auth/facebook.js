"use strict";

// Helper functions for accessing the Facebook Graph API.
const httpsRequest = require('./httpsRequest');

var Parse = require('parse/node').Parse;

const crypto = require('crypto');

function getAppSecretPath(authData, options = {}) {
  const appSecret = options.appSecret;

  if (!appSecret) {
    return '';
  }

  const appsecret_proof = crypto.createHmac('sha256', appSecret).update(authData.access_token).digest('hex');
  return `&appsecret_proof=${appsecret_proof}`;
} // Returns a promise that fulfills iff this user id is valid.


function validateAuthData(authData, options) {
  return graphRequest('me?fields=id&access_token=' + authData.access_token + getAppSecretPath(authData, options)).then(data => {
    if (data && data.id == authData.id || process.env.TESTING && authData.id === 'test') {
      return;
    }

    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is invalid for this user.');
  });
} // Returns a promise that fulfills iff this app id is valid.


function validateAppId(appIds, authData, options) {
  var access_token = authData.access_token;

  if (process.env.TESTING && access_token === 'test') {
    return Promise.resolve();
  }

  if (!appIds.length) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is not configured.');
  }

  return graphRequest('app?access_token=' + access_token + getAppSecretPath(authData, options)).then(data => {
    if (data && appIds.indexOf(data.id) != -1) {
      return;
    }

    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is invalid for this user.');
  });
} // A promisey wrapper for FB graph requests.


function graphRequest(path) {
  return httpsRequest.get('https://graph.facebook.com/' + path);
}

module.exports = {
  validateAppId: validateAppId,
  validateAuthData: validateAuthData
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9BZGFwdGVycy9BdXRoL2ZhY2Vib29rLmpzIl0sIm5hbWVzIjpbImh0dHBzUmVxdWVzdCIsInJlcXVpcmUiLCJQYXJzZSIsImNyeXB0byIsImdldEFwcFNlY3JldFBhdGgiLCJhdXRoRGF0YSIsIm9wdGlvbnMiLCJhcHBTZWNyZXQiLCJhcHBzZWNyZXRfcHJvb2YiLCJjcmVhdGVIbWFjIiwidXBkYXRlIiwiYWNjZXNzX3Rva2VuIiwiZGlnZXN0IiwidmFsaWRhdGVBdXRoRGF0YSIsImdyYXBoUmVxdWVzdCIsInRoZW4iLCJkYXRhIiwiaWQiLCJwcm9jZXNzIiwiZW52IiwiVEVTVElORyIsIkVycm9yIiwiT0JKRUNUX05PVF9GT1VORCIsInZhbGlkYXRlQXBwSWQiLCJhcHBJZHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsImxlbmd0aCIsImluZGV4T2YiLCJwYXRoIiwiZ2V0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBLE1BQU1BLFlBQVksR0FBR0MsT0FBTyxDQUFDLGdCQUFELENBQTVCOztBQUNBLElBQUlDLEtBQUssR0FBR0QsT0FBTyxDQUFDLFlBQUQsQ0FBUCxDQUFzQkMsS0FBbEM7O0FBQ0EsTUFBTUMsTUFBTSxHQUFHRixPQUFPLENBQUMsUUFBRCxDQUF0Qjs7QUFFQSxTQUFTRyxnQkFBVCxDQUEwQkMsUUFBMUIsRUFBb0NDLE9BQU8sR0FBRyxFQUE5QyxFQUFrRDtBQUNoRCxRQUFNQyxTQUFTLEdBQUdELE9BQU8sQ0FBQ0MsU0FBMUI7O0FBQ0EsTUFBSSxDQUFDQSxTQUFMLEVBQWdCO0FBQ2QsV0FBTyxFQUFQO0FBQ0Q7O0FBQ0QsUUFBTUMsZUFBZSxHQUFHTCxNQUFNLENBQzNCTSxVQURxQixDQUNWLFFBRFUsRUFDQUYsU0FEQSxFQUVyQkcsTUFGcUIsQ0FFZEwsUUFBUSxDQUFDTSxZQUZLLEVBR3JCQyxNQUhxQixDQUdkLEtBSGMsQ0FBeEI7QUFLQSxTQUFRLG9CQUFtQkosZUFBZ0IsRUFBM0M7QUFDRCxDLENBRUQ7OztBQUNBLFNBQVNLLGdCQUFULENBQTBCUixRQUExQixFQUFvQ0MsT0FBcEMsRUFBNkM7QUFDM0MsU0FBT1EsWUFBWSxDQUNqQiwrQkFDRVQsUUFBUSxDQUFDTSxZQURYLEdBRUVQLGdCQUFnQixDQUFDQyxRQUFELEVBQVdDLE9BQVgsQ0FIRCxDQUFaLENBSUxTLElBSkssQ0FJQUMsSUFBSSxJQUFJO0FBQ2IsUUFDR0EsSUFBSSxJQUFJQSxJQUFJLENBQUNDLEVBQUwsSUFBV1osUUFBUSxDQUFDWSxFQUE3QixJQUNDQyxPQUFPLENBQUNDLEdBQVIsQ0FBWUMsT0FBWixJQUF1QmYsUUFBUSxDQUFDWSxFQUFULEtBQWdCLE1BRjFDLEVBR0U7QUFDQTtBQUNEOztBQUNELFVBQU0sSUFBSWYsS0FBSyxDQUFDbUIsS0FBVixDQUNKbkIsS0FBSyxDQUFDbUIsS0FBTixDQUFZQyxnQkFEUixFQUVKLHlDQUZJLENBQU47QUFJRCxHQWZNLENBQVA7QUFnQkQsQyxDQUVEOzs7QUFDQSxTQUFTQyxhQUFULENBQXVCQyxNQUF2QixFQUErQm5CLFFBQS9CLEVBQXlDQyxPQUF6QyxFQUFrRDtBQUNoRCxNQUFJSyxZQUFZLEdBQUdOLFFBQVEsQ0FBQ00sWUFBNUI7O0FBQ0EsTUFBSU8sT0FBTyxDQUFDQyxHQUFSLENBQVlDLE9BQVosSUFBdUJULFlBQVksS0FBSyxNQUE1QyxFQUFvRDtBQUNsRCxXQUFPYyxPQUFPLENBQUNDLE9BQVIsRUFBUDtBQUNEOztBQUNELE1BQUksQ0FBQ0YsTUFBTSxDQUFDRyxNQUFaLEVBQW9CO0FBQ2xCLFVBQU0sSUFBSXpCLEtBQUssQ0FBQ21CLEtBQVYsQ0FDSm5CLEtBQUssQ0FBQ21CLEtBQU4sQ0FBWUMsZ0JBRFIsRUFFSixrQ0FGSSxDQUFOO0FBSUQ7O0FBQ0QsU0FBT1IsWUFBWSxDQUNqQixzQkFBc0JILFlBQXRCLEdBQXFDUCxnQkFBZ0IsQ0FBQ0MsUUFBRCxFQUFXQyxPQUFYLENBRHBDLENBQVosQ0FFTFMsSUFGSyxDQUVBQyxJQUFJLElBQUk7QUFDYixRQUFJQSxJQUFJLElBQUlRLE1BQU0sQ0FBQ0ksT0FBUCxDQUFlWixJQUFJLENBQUNDLEVBQXBCLEtBQTJCLENBQUMsQ0FBeEMsRUFBMkM7QUFDekM7QUFDRDs7QUFDRCxVQUFNLElBQUlmLEtBQUssQ0FBQ21CLEtBQVYsQ0FDSm5CLEtBQUssQ0FBQ21CLEtBQU4sQ0FBWUMsZ0JBRFIsRUFFSix5Q0FGSSxDQUFOO0FBSUQsR0FWTSxDQUFQO0FBV0QsQyxDQUVEOzs7QUFDQSxTQUFTUixZQUFULENBQXNCZSxJQUF0QixFQUE0QjtBQUMxQixTQUFPN0IsWUFBWSxDQUFDOEIsR0FBYixDQUFpQixnQ0FBZ0NELElBQWpELENBQVA7QUFDRDs7QUFFREUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2ZULEVBQUFBLGFBQWEsRUFBRUEsYUFEQTtBQUVmVixFQUFBQSxnQkFBZ0IsRUFBRUE7QUFGSCxDQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIGFjY2Vzc2luZyB0aGUgRmFjZWJvb2sgR3JhcGggQVBJLlxuY29uc3QgaHR0cHNSZXF1ZXN0ID0gcmVxdWlyZSgnLi9odHRwc1JlcXVlc3QnKTtcbnZhciBQYXJzZSA9IHJlcXVpcmUoJ3BhcnNlL25vZGUnKS5QYXJzZTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5mdW5jdGlvbiBnZXRBcHBTZWNyZXRQYXRoKGF1dGhEYXRhLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgYXBwU2VjcmV0ID0gb3B0aW9ucy5hcHBTZWNyZXQ7XG4gIGlmICghYXBwU2VjcmV0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IGFwcHNlY3JldF9wcm9vZiA9IGNyeXB0b1xuICAgIC5jcmVhdGVIbWFjKCdzaGEyNTYnLCBhcHBTZWNyZXQpXG4gICAgLnVwZGF0ZShhdXRoRGF0YS5hY2Nlc3NfdG9rZW4pXG4gICAgLmRpZ2VzdCgnaGV4Jyk7XG5cbiAgcmV0dXJuIGAmYXBwc2VjcmV0X3Byb29mPSR7YXBwc2VjcmV0X3Byb29mfWA7XG59XG5cbi8vIFJldHVybnMgYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgaWZmIHRoaXMgdXNlciBpZCBpcyB2YWxpZC5cbmZ1bmN0aW9uIHZhbGlkYXRlQXV0aERhdGEoYXV0aERhdGEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGdyYXBoUmVxdWVzdChcbiAgICAnbWU/ZmllbGRzPWlkJmFjY2Vzc190b2tlbj0nICtcbiAgICAgIGF1dGhEYXRhLmFjY2Vzc190b2tlbiArXG4gICAgICBnZXRBcHBTZWNyZXRQYXRoKGF1dGhEYXRhLCBvcHRpb25zKVxuICApLnRoZW4oZGF0YSA9PiB7XG4gICAgaWYgKFxuICAgICAgKGRhdGEgJiYgZGF0YS5pZCA9PSBhdXRoRGF0YS5pZCkgfHxcbiAgICAgIChwcm9jZXNzLmVudi5URVNUSU5HICYmIGF1dGhEYXRhLmlkID09PSAndGVzdCcpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgIFBhcnNlLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQsXG4gICAgICAnRmFjZWJvb2sgYXV0aCBpcyBpbnZhbGlkIGZvciB0aGlzIHVzZXIuJ1xuICAgICk7XG4gIH0pO1xufVxuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIGlmZiB0aGlzIGFwcCBpZCBpcyB2YWxpZC5cbmZ1bmN0aW9uIHZhbGlkYXRlQXBwSWQoYXBwSWRzLCBhdXRoRGF0YSwgb3B0aW9ucykge1xuICB2YXIgYWNjZXNzX3Rva2VuID0gYXV0aERhdGEuYWNjZXNzX3Rva2VuO1xuICBpZiAocHJvY2Vzcy5lbnYuVEVTVElORyAmJiBhY2Nlc3NfdG9rZW4gPT09ICd0ZXN0Jykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBpZiAoIWFwcElkcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICBQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELFxuICAgICAgJ0ZhY2Vib29rIGF1dGggaXMgbm90IGNvbmZpZ3VyZWQuJ1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIGdyYXBoUmVxdWVzdChcbiAgICAnYXBwP2FjY2Vzc190b2tlbj0nICsgYWNjZXNzX3Rva2VuICsgZ2V0QXBwU2VjcmV0UGF0aChhdXRoRGF0YSwgb3B0aW9ucylcbiAgKS50aGVuKGRhdGEgPT4ge1xuICAgIGlmIChkYXRhICYmIGFwcElkcy5pbmRleE9mKGRhdGEuaWQpICE9IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgIFBhcnNlLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQsXG4gICAgICAnRmFjZWJvb2sgYXV0aCBpcyBpbnZhbGlkIGZvciB0aGlzIHVzZXIuJ1xuICAgICk7XG4gIH0pO1xufVxuXG4vLyBBIHByb21pc2V5IHdyYXBwZXIgZm9yIEZCIGdyYXBoIHJlcXVlc3RzLlxuZnVuY3Rpb24gZ3JhcGhSZXF1ZXN0KHBhdGgpIHtcbiAgcmV0dXJuIGh0dHBzUmVxdWVzdC5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLycgKyBwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZhbGlkYXRlQXBwSWQ6IHZhbGlkYXRlQXBwSWQsXG4gIHZhbGlkYXRlQXV0aERhdGE6IHZhbGlkYXRlQXV0aERhdGEsXG59O1xuIl19