"use strict";

// This file contains helpers for running operations in REST format.
// The goal is that handlers that explicitly handle an express route
// should just be shallow wrappers around things in this file, but
// these functions should not explicitly depend on the request
// object.
// This means that one of these handlers can support multiple
// routes. That's useful for the routes that do really similar
// things.
var Parse = require('parse/node').Parse;

var RestQuery = require('./RestQuery');

var RestWrite = require('./RestWrite');

var triggers = require('./triggers');

function checkTriggers(className, config, types) {
  return types.some(triggerType => {
    return triggers.getTrigger(className, triggers.Types[triggerType], config.applicationId);
  });
}

function checkLiveQuery(className, config) {
  return config.liveQueryController && config.liveQueryController.hasLiveQuery(className);
} // Returns a promise for an object with optional keys 'results' and 'count'.


function find(config, auth, className, restWhere, restOptions, clientSDK) {
  enforceRoleSecurity('find', className, auth);
  return triggers.maybeRunQueryTrigger(triggers.Types.beforeFind, className, restWhere, restOptions, config, auth).then(result => {
    restWhere = result.restWhere || restWhere;
    restOptions = result.restOptions || restOptions;
    const query = new RestQuery(config, auth, className, restWhere, restOptions, clientSDK);
    return query.execute();
  });
} // get is just like find but only queries an objectId.


const get = (config, auth, className, objectId, restOptions, clientSDK) => {
  var restWhere = {
    objectId
  };
  enforceRoleSecurity('get', className, auth);
  return triggers.maybeRunQueryTrigger(triggers.Types.beforeFind, className, restWhere, restOptions, config, auth, true).then(result => {
    restWhere = result.restWhere || restWhere;
    restOptions = result.restOptions || restOptions;
    const query = new RestQuery(config, auth, className, restWhere, restOptions, clientSDK);
    return query.execute();
  });
}; // Returns a promise that doesn't resolve to any useful value.


function del(config, auth, className, objectId) {
  if (typeof objectId !== 'string') {
    throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad objectId');
  }

  if (className === '_User' && auth.isUnauthenticated()) {
    throw new Parse.Error(Parse.Error.SESSION_MISSING, 'Insufficient auth to delete user');
  }

  enforceRoleSecurity('delete', className, auth);
  let inflatedObject;
  let schemaController;
  return Promise.resolve().then(() => {
    const hasTriggers = checkTriggers(className, config, ['beforeDelete', 'afterDelete']);
    const hasLiveQuery = checkLiveQuery(className, config);

    if (hasTriggers || hasLiveQuery || className == '_Session') {
      return new RestQuery(config, auth, className, {
        objectId
      }).execute({
        op: 'delete'
      }).then(response => {
        if (response && response.results && response.results.length) {
          const firstResult = response.results[0];
          firstResult.className = className;

          if (className === '_Session' && !auth.isMaster) {
            if (!auth.user || firstResult.user.objectId !== auth.user.id) {
              throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');
            }
          }

          var cacheAdapter = config.cacheController;
          cacheAdapter.user.del(firstResult.sessionToken);
          inflatedObject = Parse.Object.fromJSON(firstResult);
          return triggers.maybeRunTrigger(triggers.Types.beforeDelete, auth, inflatedObject, null, config);
        }

        throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found for delete.');
      });
    }

    return Promise.resolve({});
  }).then(() => {
    if (!auth.isMaster) {
      return auth.getUserRoles();
    } else {
      return;
    }
  }).then(() => config.database.loadSchema()).then(s => {
    schemaController = s;
    const options = {};

    if (!auth.isMaster) {
      options.acl = ['*'];

      if (auth.user) {
        options.acl.push(auth.user.id);
        options.acl = options.acl.concat(auth.userRoles);
      }
    }

    return config.database.destroy(className, {
      objectId: objectId
    }, options, schemaController);
  }).then(() => {
    // Notify LiveQuery server if possible
    const perms = schemaController.getClassLevelPermissions(className);
    config.liveQueryController.onAfterDelete(className, inflatedObject, null, perms);
    return triggers.maybeRunTrigger(triggers.Types.afterDelete, auth, inflatedObject, null, config);
  }).catch(error => {
    handleSessionMissingError(error, className, auth);
  });
} // Returns a promise for a {response, status, location} object.


function create(config, auth, className, restObject, clientSDK) {
  enforceRoleSecurity('create', className, auth);
  var write = new RestWrite(config, auth, className, null, restObject, null, clientSDK);
  return write.execute();
} // Returns a promise that contains the fields of the update that the
// REST API is supposed to return.
// Usually, this is just updatedAt.


function update(config, auth, className, restWhere, restObject, clientSDK) {
  enforceRoleSecurity('update', className, auth);
  return Promise.resolve().then(() => {
    const hasTriggers = checkTriggers(className, config, ['beforeSave', 'afterSave']);
    const hasLiveQuery = checkLiveQuery(className, config);

    if (hasTriggers || hasLiveQuery) {
      // Do not use find, as it runs the before finds
      return new RestQuery(config, auth, className, restWhere, undefined, undefined, false).execute({
        op: 'update'
      });
    }

    return Promise.resolve({});
  }).then(({
    results
  }) => {
    var originalRestObject;

    if (results && results.length) {
      originalRestObject = results[0];
    }

    return new RestWrite(config, auth, className, restWhere, restObject, originalRestObject, clientSDK).execute();
  }).catch(error => {
    handleSessionMissingError(error, className, auth);
  });
}

function handleSessionMissingError(error, className, auth) {
  // If we're trying to update a user without / with bad session token
  if (className === '_User' && error.code === Parse.Error.OBJECT_NOT_FOUND && !auth.isMaster) {
    throw new Parse.Error(Parse.Error.SESSION_MISSING, 'Insufficient auth.');
  }

  throw error;
}

const classesWithMasterOnlyAccess = ['_JobStatus', '_PushStatus', '_Hooks', '_GlobalConfig', '_JobSchedule']; // Disallowing access to the _Role collection except by master key

function enforceRoleSecurity(method, className, auth) {
  if (className === '_Installation' && !auth.isMaster) {
    if (method === 'delete' || method === 'find') {
      const error = `Clients aren't allowed to perform the ${method} operation on the installation collection.`;
      throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);
    }
  } //all volatileClasses are masterKey only


  if (classesWithMasterOnlyAccess.indexOf(className) >= 0 && !auth.isMaster) {
    const error = `Clients aren't allowed to perform the ${method} operation on the ${className} collection.`;
    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);
  } // readOnly masterKey is not allowed


  if (auth.isReadOnly && (method === 'delete' || method === 'create' || method === 'update')) {
    const error = `read-only masterKey isn't allowed to perform the ${method} operation.`;
    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);
  }
}

module.exports = {
  create,
  del,
  find,
  get,
  update
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXN0LmpzIl0sIm5hbWVzIjpbIlBhcnNlIiwicmVxdWlyZSIsIlJlc3RRdWVyeSIsIlJlc3RXcml0ZSIsInRyaWdnZXJzIiwiY2hlY2tUcmlnZ2VycyIsImNsYXNzTmFtZSIsImNvbmZpZyIsInR5cGVzIiwic29tZSIsInRyaWdnZXJUeXBlIiwiZ2V0VHJpZ2dlciIsIlR5cGVzIiwiYXBwbGljYXRpb25JZCIsImNoZWNrTGl2ZVF1ZXJ5IiwibGl2ZVF1ZXJ5Q29udHJvbGxlciIsImhhc0xpdmVRdWVyeSIsImZpbmQiLCJhdXRoIiwicmVzdFdoZXJlIiwicmVzdE9wdGlvbnMiLCJjbGllbnRTREsiLCJlbmZvcmNlUm9sZVNlY3VyaXR5IiwibWF5YmVSdW5RdWVyeVRyaWdnZXIiLCJiZWZvcmVGaW5kIiwidGhlbiIsInJlc3VsdCIsInF1ZXJ5IiwiZXhlY3V0ZSIsImdldCIsIm9iamVjdElkIiwiZGVsIiwiRXJyb3IiLCJJTlZBTElEX0pTT04iLCJpc1VuYXV0aGVudGljYXRlZCIsIlNFU1NJT05fTUlTU0lORyIsImluZmxhdGVkT2JqZWN0Iiwic2NoZW1hQ29udHJvbGxlciIsIlByb21pc2UiLCJyZXNvbHZlIiwiaGFzVHJpZ2dlcnMiLCJvcCIsInJlc3BvbnNlIiwicmVzdWx0cyIsImxlbmd0aCIsImZpcnN0UmVzdWx0IiwiaXNNYXN0ZXIiLCJ1c2VyIiwiaWQiLCJJTlZBTElEX1NFU1NJT05fVE9LRU4iLCJjYWNoZUFkYXB0ZXIiLCJjYWNoZUNvbnRyb2xsZXIiLCJzZXNzaW9uVG9rZW4iLCJPYmplY3QiLCJmcm9tSlNPTiIsIm1heWJlUnVuVHJpZ2dlciIsImJlZm9yZURlbGV0ZSIsIk9CSkVDVF9OT1RfRk9VTkQiLCJnZXRVc2VyUm9sZXMiLCJkYXRhYmFzZSIsImxvYWRTY2hlbWEiLCJzIiwib3B0aW9ucyIsImFjbCIsInB1c2giLCJjb25jYXQiLCJ1c2VyUm9sZXMiLCJkZXN0cm95IiwicGVybXMiLCJnZXRDbGFzc0xldmVsUGVybWlzc2lvbnMiLCJvbkFmdGVyRGVsZXRlIiwiYWZ0ZXJEZWxldGUiLCJjYXRjaCIsImVycm9yIiwiaGFuZGxlU2Vzc2lvbk1pc3NpbmdFcnJvciIsImNyZWF0ZSIsInJlc3RPYmplY3QiLCJ3cml0ZSIsInVwZGF0ZSIsInVuZGVmaW5lZCIsIm9yaWdpbmFsUmVzdE9iamVjdCIsImNvZGUiLCJjbGFzc2VzV2l0aE1hc3Rlck9ubHlBY2Nlc3MiLCJtZXRob2QiLCJPUEVSQVRJT05fRk9SQklEREVOIiwiaW5kZXhPZiIsImlzUmVhZE9ubHkiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxJQUFJQSxLQUFLLEdBQUdDLE9BQU8sQ0FBQyxZQUFELENBQVAsQ0FBc0JELEtBQWxDOztBQUVBLElBQUlFLFNBQVMsR0FBR0QsT0FBTyxDQUFDLGFBQUQsQ0FBdkI7O0FBQ0EsSUFBSUUsU0FBUyxHQUFHRixPQUFPLENBQUMsYUFBRCxDQUF2Qjs7QUFDQSxJQUFJRyxRQUFRLEdBQUdILE9BQU8sQ0FBQyxZQUFELENBQXRCOztBQUVBLFNBQVNJLGFBQVQsQ0FBdUJDLFNBQXZCLEVBQWtDQyxNQUFsQyxFQUEwQ0MsS0FBMUMsRUFBaUQ7QUFDL0MsU0FBT0EsS0FBSyxDQUFDQyxJQUFOLENBQVdDLFdBQVcsSUFBSTtBQUMvQixXQUFPTixRQUFRLENBQUNPLFVBQVQsQ0FDTEwsU0FESyxFQUVMRixRQUFRLENBQUNRLEtBQVQsQ0FBZUYsV0FBZixDQUZLLEVBR0xILE1BQU0sQ0FBQ00sYUFIRixDQUFQO0FBS0QsR0FOTSxDQUFQO0FBT0Q7O0FBRUQsU0FBU0MsY0FBVCxDQUF3QlIsU0FBeEIsRUFBbUNDLE1BQW5DLEVBQTJDO0FBQ3pDLFNBQ0VBLE1BQU0sQ0FBQ1EsbUJBQVAsSUFDQVIsTUFBTSxDQUFDUSxtQkFBUCxDQUEyQkMsWUFBM0IsQ0FBd0NWLFNBQXhDLENBRkY7QUFJRCxDLENBRUQ7OztBQUNBLFNBQVNXLElBQVQsQ0FB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QUFvQy9FLFNBQXBDLEtBQWtELENBQWxELElBQXVELENBQUNZLElBQUksQ0FBQzRCLFFBQWpFLEVBQTJFO0FBQ3pFLFVBQU0yQixLQUFLLEdBQUkseUNBQXdDVSxNQUFPLHFCQUFvQjdFLFNBQVUsY0FBNUY7QUFDQSxVQUFNLElBQUlOLEtBQUssQ0FBQ2dDLEtBQVYsQ0FBZ0JoQyxLQUFLLENBQUNnQyxLQUFOLENBQVlvRCxtQkFBNUIsRUFBaURYLEtBQWpELENBQU47QUFDRCxHQVptRCxDQWNwRDs7O0FBQ0EsTUFDRXZELElBQUksQ0FBQ29FLFVBQUwsS0FDQ0gsTUFBTSxLQUFLLFFBQVgsSUFBdUJBLE1BQU0sS0FBSyxRQUFsQyxJQUE4Q0EsTUFBTSxLQUFLLFFBRDFELENBREYsRUFHRTtBQUNBLFVBQU1WLEtBQUssR0FBSSxvREFBbURVLE1BQU8sYUFBekU7QUFDQSxVQUFNLElBQUluRixLQUFLLENBQUNnQyxLQUFWLENBQWdCaEMsS0FBSyxDQUFDZ0MsS0FBTixDQUFZb0QsbUJBQTVCLEVBQWlEWCxLQUFqRCxDQUFOO0FBQ0Q7QUFDRjs7QUFFRGMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2ZiLEVBQUFBLE1BRGU7QUFFZjVDLEVBQUFBLEdBRmU7QUFHZmQsRUFBQUEsSUFIZTtBQUlmWSxFQUFBQSxHQUplO0FBS2ZpRCxFQUFBQTtBQUxlLENBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGNvbnRhaW5zIGhlbHBlcnMgZm9yIHJ1bm5pbmcgb3BlcmF0aW9ucyBpbiBSRVNUIGZvcm1hdC5cbi8vIFRoZSBnb2FsIGlzIHRoYXQgaGFuZGxlcnMgdGhhdCBleHBsaWNpdGx5IGhhbmRsZSBhbiBleHByZXNzIHJvdXRlXG4vLyBzaG91bGQganVzdCBiZSBzaGFsbG93IHdyYXBwZXJzIGFyb3VuZCB0aGluZ3MgaW4gdGhpcyBmaWxlLCBidXRcbi8vIHRoZXNlIGZ1bmN0aW9ucyBzaG91bGQgbm90IGV4cGxpY2l0bHkgZGVwZW5kIG9uIHRoZSByZXF1ZXN0XG4vLyBvYmplY3QuXG4vLyBUaGlzIG1lYW5zIHRoYXQgb25lIG9mIHRoZXNlIGhhbmRsZXJzIGNhbiBzdXBwb3J0IG11bHRpcGxlXG4vLyByb3V0ZXMuIFRoYXQncyB1c2VmdWwgZm9yIHRoZSByb3V0ZXMgdGhhdCBkbyByZWFsbHkgc2ltaWxhclxuLy8gdGhpbmdzLlxuXG52YXIgUGFyc2UgPSByZXF1aXJlKCdwYXJzZS9ub2RlJykuUGFyc2U7XG5cbnZhciBSZXN0UXVlcnkgPSByZXF1aXJlKCcuL1Jlc3RRdWVyeScpO1xudmFyIFJlc3RXcml0ZSA9IHJlcXVpcmUoJy4vUmVzdFdyaXRlJyk7XG52YXIgdHJpZ2dlcnMgPSByZXF1aXJlKCcuL3RyaWdnZXJzJyk7XG5cbmZ1bmN0aW9uIGNoZWNrVHJpZ2dlcnMoY2xhc3NOYW1lLCBjb25maWcsIHR5cGVzKSB7XG4gIHJldHVybiB0eXBlcy5zb21lKHRyaWdnZXJUeXBlID0+IHtcbiAgICByZXR1cm4gdHJpZ2dlcnMuZ2V0VHJpZ2dlcihcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIHRyaWdnZXJzLlR5cGVzW3RyaWdnZXJUeXBlXSxcbiAgICAgIGNvbmZpZy5hcHBsaWNhdGlvbklkXG4gICAgKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrTGl2ZVF1ZXJ5KGNsYXNzTmFtZSwgY29uZmlnKSB7XG4gIHJldHVybiAoXG4gICAgY29uZmlnLmxpdmVRdWVyeUNvbnRyb2xsZXIgJiZcbiAgICBjb25maWcubGl2ZVF1ZXJ5Q29udHJvbGxlci5oYXNMaXZlUXVlcnkoY2xhc3NOYW1lKVxuICApO1xufVxuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwga2V5cyAncmVzdWx0cycgYW5kICdjb3VudCcuXG5mdW5jdGlvbiBmaW5kKGNvbmZpZywgYXV0aCwgY2xhc3NOYW1lLCByZXN0V2hlcmUsIHJlc3RPcHRpb25zLCBjbGllbnRTREspIHtcbiAgZW5mb3JjZVJvbGVTZWN1cml0eSgnZmluZCcsIGNsYXNzTmFtZSwgYXV0aCk7XG4gIHJldHVybiB0cmlnZ2Vyc1xuICAgIC5tYXliZVJ1blF1ZXJ5VHJpZ2dlcihcbiAgICAgIHRyaWdnZXJzLlR5cGVzLmJlZm9yZUZpbmQsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICByZXN0V2hlcmUsXG4gICAgICByZXN0T3B0aW9ucyxcbiAgICAgIGNvbmZpZyxcbiAgICAgIGF1dGhcbiAgICApXG4gICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIHJlc3RXaGVyZSA9IHJlc3VsdC5yZXN0V2hlcmUgfHwgcmVzdFdoZXJlO1xuICAgICAgcmVzdE9wdGlvbnMgPSByZXN1bHQucmVzdE9wdGlvbnMgfHwgcmVzdE9wdGlvbnM7XG4gICAgICBjb25zdCBxdWVyeSA9IG5ldyBSZXN0UXVlcnkoXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgYXV0aCxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICByZXN0V2hlcmUsXG4gICAgICAgIHJlc3RPcHRpb25zLFxuICAgICAgICBjbGllbnRTREtcbiAgICAgICk7XG4gICAgICByZXR1cm4gcXVlcnkuZXhlY3V0ZSgpO1xuICAgIH0pO1xufVxuXG4vLyBnZXQgaXMganVzdCBsaWtlIGZpbmQgYnV0IG9ubHkgcXVlcmllcyBhbiBvYmplY3RJZC5cbmNvbnN0IGdldCA9IChjb25maWcsIGF1dGgsIGNsYXNzTmFtZSwgb2JqZWN0SWQsIHJlc3RPcHRpb25zLCBjbGllbnRTREspID0+IHtcbiAgdmFyIHJlc3RXaGVyZSA9IHsgb2JqZWN0SWQgfTtcbiAgZW5mb3JjZVJvbGVTZWN1cml0eSgnZ2V0JywgY2xhc3NOYW1lLCBhdXRoKTtcbiAgcmV0dXJuIHRyaWdnZXJzXG4gICAgLm1heWJlUnVuUXVlcnlUcmlnZ2VyKFxuICAgICAgdHJpZ2dlcnMuVHlwZXMuYmVmb3JlRmluZCxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIHJlc3RXaGVyZSxcbiAgICAgIHJlc3RPcHRpb25zLFxuICAgICAgY29uZmlnLFxuICAgICAgYXV0aCxcbiAgICAgIHRydWVcbiAgICApXG4gICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIHJlc3RXaGVyZSA9IHJlc3VsdC5yZXN0V2hlcmUgfHwgcmVzdFdoZXJlO1xuICAgICAgcmVzdE9wdGlvbnMgPSByZXN1bHQucmVzdE9wdGlvbnMgfHwgcmVzdE9wdGlvbnM7XG4gICAgICBjb25zdCBxdWVyeSA9IG5ldyBSZXN0UXVlcnkoXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgYXV0aCxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICByZXN0V2hlcmUsXG4gICAgICAgIHJlc3RPcHRpb25zLFxuICAgICAgICBjbGllbnRTREtcbiAgICAgICk7XG4gICAgICByZXR1cm4gcXVlcnkuZXhlY3V0ZSgpO1xuICAgIH0pO1xufTtcblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBkb2Vzbid0IHJlc29sdmUgdG8gYW55IHVzZWZ1bCB2YWx1ZS5cbmZ1bmN0aW9uIGRlbChjb25maWcsIGF1dGgsIGNsYXNzTmFtZSwgb2JqZWN0SWQpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3RJZCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuSU5WQUxJRF9KU09OLCAnYmFkIG9iamVjdElkJyk7XG4gIH1cblxuICBpZiAoY2xhc3NOYW1lID09PSAnX1VzZXInICYmIGF1dGguaXNVbmF1dGhlbnRpY2F0ZWQoKSkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgIFBhcnNlLkVycm9yLlNFU1NJT05fTUlTU0lORyxcbiAgICAgICdJbnN1ZmZpY2llbnQgYXV0aCB0byBkZWxldGUgdXNlcidcbiAgICApO1xuICB9XG5cbiAgZW5mb3JjZVJvbGVTZWN1cml0eSgnZGVsZXRlJywgY2xhc3NOYW1lLCBhdXRoKTtcblxuICBsZXQgaW5mbGF0ZWRPYmplY3Q7XG4gIGxldCBzY2hlbWFDb250cm9sbGVyO1xuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IGhhc1RyaWdnZXJzID0gY2hlY2tUcmlnZ2VycyhjbGFzc05hbWUsIGNvbmZpZywgW1xuICAgICAgICAnYmVmb3JlRGVsZXRlJyxcbiAgICAgICAgJ2FmdGVyRGVsZXRlJyxcbiAgICAgIF0pO1xuICAgICAgY29uc3QgaGFzTGl2ZVF1ZXJ5ID0gY2hlY2tMaXZlUXVlcnkoY2xhc3NOYW1lLCBjb25maWcpO1xuICAgICAgaWYgKGhhc1RyaWdnZXJzIHx8IGhhc0xpdmVRdWVyeSB8fCBjbGFzc05hbWUgPT0gJ19TZXNzaW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3RRdWVyeShjb25maWcsIGF1dGgsIGNsYXNzTmFtZSwgeyBvYmplY3RJZCB9KVxuICAgICAgICAgIC5leGVjdXRlKHsgb3A6ICdkZWxldGUnIH0pXG4gICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLnJlc3VsdHMgJiYgcmVzcG9uc2UucmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RSZXN1bHQgPSByZXNwb25zZS5yZXN1bHRzWzBdO1xuICAgICAgICAgICAgICBmaXJzdFJlc3VsdC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT09ICdfU2Vzc2lvbicgJiYgIWF1dGguaXNNYXN0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWF1dGgudXNlciB8fCBmaXJzdFJlc3VsdC51c2VyLm9iamVjdElkICE9PSBhdXRoLnVzZXIuaWQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgICAgICAgICAgICAgICAgUGFyc2UuRXJyb3IuSU5WQUxJRF9TRVNTSU9OX1RPS0VOLFxuICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBzZXNzaW9uIHRva2VuJ1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGNhY2hlQWRhcHRlciA9IGNvbmZpZy5jYWNoZUNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgIGNhY2hlQWRhcHRlci51c2VyLmRlbChmaXJzdFJlc3VsdC5zZXNzaW9uVG9rZW4pO1xuICAgICAgICAgICAgICBpbmZsYXRlZE9iamVjdCA9IFBhcnNlLk9iamVjdC5mcm9tSlNPTihmaXJzdFJlc3VsdCk7XG4gICAgICAgICAgICAgIHJldHVybiB0cmlnZ2Vycy5tYXliZVJ1blRyaWdnZXIoXG4gICAgICAgICAgICAgICAgdHJpZ2dlcnMuVHlwZXMuYmVmb3JlRGVsZXRlLFxuICAgICAgICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgICAgICAgaW5mbGF0ZWRPYmplY3QsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBjb25maWdcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgICAgICAgICAgUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCxcbiAgICAgICAgICAgICAgJ09iamVjdCBub3QgZm91bmQgZm9yIGRlbGV0ZS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIWF1dGguaXNNYXN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGF1dGguZ2V0VXNlclJvbGVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiBjb25maWcuZGF0YWJhc2UubG9hZFNjaGVtYSgpKVxuICAgIC50aGVuKHMgPT4ge1xuICAgICAgc2NoZW1hQ29udHJvbGxlciA9IHM7XG4gICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICBpZiAoIWF1dGguaXNNYXN0ZXIpIHtcbiAgICAgICAgb3B0aW9ucy5hY2wgPSBbJyonXTtcbiAgICAgICAgaWYgKGF1dGgudXNlcikge1xuICAgICAgICAgIG9wdGlvbnMuYWNsLnB1c2goYXV0aC51c2VyLmlkKTtcbiAgICAgICAgICBvcHRpb25zLmFjbCA9IG9wdGlvbnMuYWNsLmNvbmNhdChhdXRoLnVzZXJSb2xlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbmZpZy5kYXRhYmFzZS5kZXN0cm95KFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHtcbiAgICAgICAgICBvYmplY3RJZDogb2JqZWN0SWQsXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHNjaGVtYUNvbnRyb2xsZXJcbiAgICAgICk7XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICAvLyBOb3RpZnkgTGl2ZVF1ZXJ5IHNlcnZlciBpZiBwb3NzaWJsZVxuICAgICAgY29uc3QgcGVybXMgPSBzY2hlbWFDb250cm9sbGVyLmdldENsYXNzTGV2ZWxQZXJtaXNzaW9ucyhjbGFzc05hbWUpO1xuICAgICAgY29uZmlnLmxpdmVRdWVyeUNvbnRyb2xsZXIub25BZnRlckRlbGV0ZShcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBpbmZsYXRlZE9iamVjdCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGVybXNcbiAgICAgICk7XG4gICAgICByZXR1cm4gdHJpZ2dlcnMubWF5YmVSdW5UcmlnZ2VyKFxuICAgICAgICB0cmlnZ2Vycy5UeXBlcy5hZnRlckRlbGV0ZSxcbiAgICAgICAgYXV0aCxcbiAgICAgICAgaW5mbGF0ZWRPYmplY3QsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNvbmZpZ1xuICAgICAgKTtcbiAgICB9KVxuICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICBoYW5kbGVTZXNzaW9uTWlzc2luZ0Vycm9yKGVycm9yLCBjbGFzc05hbWUsIGF1dGgpO1xuICAgIH0pO1xufVxuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYSB7cmVzcG9uc2UsIHN0YXR1cywgbG9jYXRpb259IG9iamVjdC5cbmZ1bmN0aW9uIGNyZWF0ZShjb25maWcsIGF1dGgsIGNsYXNzTmFtZSwgcmVzdE9iamVjdCwgY2xpZW50U0RLKSB7XG4gIGVuZm9yY2VSb2xlU2VjdXJpdHkoJ2NyZWF0ZScsIGNsYXNzTmFtZSwgYXV0aCk7XG4gIHZhciB3cml0ZSA9IG5ldyBSZXN0V3JpdGUoXG4gICAgY29uZmlnLFxuICAgIGF1dGgsXG4gICAgY2xhc3NOYW1lLFxuICAgIG51bGwsXG4gICAgcmVzdE9iamVjdCxcbiAgICBudWxsLFxuICAgIGNsaWVudFNES1xuICApO1xuICByZXR1cm4gd3JpdGUuZXhlY3V0ZSgpO1xufVxuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGNvbnRhaW5zIHRoZSBmaWVsZHMgb2YgdGhlIHVwZGF0ZSB0aGF0IHRoZVxuLy8gUkVTVCBBUEkgaXMgc3VwcG9zZWQgdG8gcmV0dXJuLlxuLy8gVXN1YWxseSwgdGhpcyBpcyBqdXN0IHVwZGF0ZWRBdC5cbmZ1bmN0aW9uIHVwZGF0ZShjb25maWcsIGF1dGgsIGNsYXNzTmFtZSwgcmVzdFdoZXJlLCByZXN0T2JqZWN0LCBjbGllbnRTREspIHtcbiAgZW5mb3JjZVJvbGVTZWN1cml0eSgndXBkYXRlJywgY2xhc3NOYW1lLCBhdXRoKTtcblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBoYXNUcmlnZ2VycyA9IGNoZWNrVHJpZ2dlcnMoY2xhc3NOYW1lLCBjb25maWcsIFtcbiAgICAgICAgJ2JlZm9yZVNhdmUnLFxuICAgICAgICAnYWZ0ZXJTYXZlJyxcbiAgICAgIF0pO1xuICAgICAgY29uc3QgaGFzTGl2ZVF1ZXJ5ID0gY2hlY2tMaXZlUXVlcnkoY2xhc3NOYW1lLCBjb25maWcpO1xuICAgICAgaWYgKGhhc1RyaWdnZXJzIHx8IGhhc0xpdmVRdWVyeSkge1xuICAgICAgICAvLyBEbyBub3QgdXNlIGZpbmQsIGFzIGl0IHJ1bnMgdGhlIGJlZm9yZSBmaW5kc1xuICAgICAgICByZXR1cm4gbmV3IFJlc3RRdWVyeShcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgYXV0aCxcbiAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgcmVzdFdoZXJlLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKS5leGVjdXRlKHtcbiAgICAgICAgICBvcDogJ3VwZGF0ZScsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfSlcbiAgICAudGhlbigoeyByZXN1bHRzIH0pID0+IHtcbiAgICAgIHZhciBvcmlnaW5hbFJlc3RPYmplY3Q7XG4gICAgICBpZiAocmVzdWx0cyAmJiByZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICBvcmlnaW5hbFJlc3RPYmplY3QgPSByZXN1bHRzWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSZXN0V3JpdGUoXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgYXV0aCxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICByZXN0V2hlcmUsXG4gICAgICAgIHJlc3RPYmplY3QsXG4gICAgICAgIG9yaWdpbmFsUmVzdE9iamVjdCxcbiAgICAgICAgY2xpZW50U0RLXG4gICAgICApLmV4ZWN1dGUoKTtcbiAgICB9KVxuICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICBoYW5kbGVTZXNzaW9uTWlzc2luZ0Vycm9yKGVycm9yLCBjbGFzc05hbWUsIGF1dGgpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTZXNzaW9uTWlzc2luZ0Vycm9yKGVycm9yLCBjbGFzc05hbWUsIGF1dGgpIHtcbiAgLy8gSWYgd2UncmUgdHJ5aW5nIHRvIHVwZGF0ZSBhIHVzZXIgd2l0aG91dCAvIHdpdGggYmFkIHNlc3Npb24gdG9rZW5cbiAgaWYgKFxuICAgIGNsYXNzTmFtZSA9PT0gJ19Vc2VyJyAmJlxuICAgIGVycm9yLmNvZGUgPT09IFBhcnNlLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQgJiZcbiAgICAhYXV0aC5pc01hc3RlclxuICApIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuU0VTU0lPTl9NSVNTSU5HLCAnSW5zdWZmaWNpZW50IGF1dGguJyk7XG4gIH1cbiAgdGhyb3cgZXJyb3I7XG59XG5cbmNvbnN0IGNsYXNzZXNXaXRoTWFzdGVyT25seUFjY2VzcyA9IFtcbiAgJ19Kb2JTdGF0dXMnLFxuICAnX1B1c2hTdGF0dXMnLFxuICAnX0hvb2tzJyxcbiAgJ19HbG9iYWxDb25maWcnLFxuICAnX0pvYlNjaGVkdWxlJyxcbl07XG4vLyBEaXNhbGxvd2luZyBhY2Nlc3MgdG8gdGhlIF9Sb2xlIGNvbGxlY3Rpb24gZXhjZXB0IGJ5IG1hc3RlciBrZXlcbmZ1bmN0aW9uIGVuZm9yY2VSb2xlU2VjdXJpdHkobWV0aG9kLCBjbGFzc05hbWUsIGF1dGgpIHtcbiAgaWYgKGNsYXNzTmFtZSA9PT0gJ19JbnN0YWxsYXRpb24nICYmICFhdXRoLmlzTWFzdGVyKSB7XG4gICAgaWYgKG1ldGhvZCA9PT0gJ2RlbGV0ZScgfHwgbWV0aG9kID09PSAnZmluZCcpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gYENsaWVudHMgYXJlbid0IGFsbG93ZWQgdG8gcGVyZm9ybSB0aGUgJHttZXRob2R9IG9wZXJhdGlvbiBvbiB0aGUgaW5zdGFsbGF0aW9uIGNvbGxlY3Rpb24uYDtcbiAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PUEVSQVRJT05fRk9SQklEREVOLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy9hbGwgdm9sYXRpbGVDbGFzc2VzIGFyZSBtYXN0ZXJLZXkgb25seVxuICBpZiAoY2xhc3Nlc1dpdGhNYXN0ZXJPbmx5QWNjZXNzLmluZGV4T2YoY2xhc3NOYW1lKSA+PSAwICYmICFhdXRoLmlzTWFzdGVyKSB7XG4gICAgY29uc3QgZXJyb3IgPSBgQ2xpZW50cyBhcmVuJ3QgYWxsb3dlZCB0byBwZXJmb3JtIHRoZSAke21ldGhvZH0gb3BlcmF0aW9uIG9uIHRoZSAke2NsYXNzTmFtZX0gY29sbGVjdGlvbi5gO1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PUEVSQVRJT05fRk9SQklEREVOLCBlcnJvcik7XG4gIH1cblxuICAvLyByZWFkT25seSBtYXN0ZXJLZXkgaXMgbm90IGFsbG93ZWRcbiAgaWYgKFxuICAgIGF1dGguaXNSZWFkT25seSAmJlxuICAgIChtZXRob2QgPT09ICdkZWxldGUnIHx8IG1ldGhvZCA9PT0gJ2NyZWF0ZScgfHwgbWV0aG9kID09PSAndXBkYXRlJylcbiAgKSB7XG4gICAgY29uc3QgZXJyb3IgPSBgcmVhZC1vbmx5IG1hc3RlcktleSBpc24ndCBhbGxvd2VkIHRvIHBlcmZvcm0gdGhlICR7bWV0aG9kfSBvcGVyYXRpb24uYDtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT1BFUkFUSU9OX0ZPUkJJRERFTiwgZXJyb3IpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGUsXG4gIGRlbCxcbiAgZmluZCxcbiAgZ2V0LFxuICB1cGRhdGUsXG59O1xuIl19